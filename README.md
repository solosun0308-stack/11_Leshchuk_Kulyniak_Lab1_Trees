# 11_Leshchuk_Kulyniak_Lab1_Trees
1.1 Алгоритми Пріма та Крускала (MST)
Ефективність: В ході тестування було помічено, що швидкість алгоритмів суттєво залежить від щільності графа (ймовірності появи ребер). Алгоритм Крускала показав себе краще на розріджених графах, оскільки його складність O(ElogE) більше залежить від кількості ребер. Алгоритм Пріма (з використанням пріоритетної черги) продемонстрував стабільність на більш щільних графах.
Порівняння з NetworkX: Вбудована функція networkx виявилася значно швидшою за власні реалізації (особливо на графах N>200). Це пояснюється використанням оптимізованих структур даних на рівні C та ефективнішою роботою з пам'яттю.
Графіки: На графіках чітко видно експоненціальне зростання часу виконання для власних реалізацій при збільшенні кількості вершин, тоді як бібліотечна функція має більш пологу криву.
1.2 Алгоритм Белмана-Форда
Продуктивність: Алгоритм Белмана-Форда має складність O(V⋅E), що робить його помітно повільнішим за networkx при ідентичних розмірах графа. При збільшенні кількості вершин від 500 час реалізації сильно перевищував за час роботи networkx, що вказує на необхідність оптимізації алгоритму.
Робота з від’ємними вагами: Алгоритм успішно коректно обробляє ребра з від’ємною вагою. Під час експерименту з циклами від’ємної ваги алгоритм, згідно з логікою, повертав помилку/повідомлення про неможливість знаходження найкоротшого шляху, що підтверджує правильність реалізації детекції циклів.
Порівняння: NetworkX використовує додаткові оптимізації (наприклад, ранню зупинку, якщо на ітерації нічого не змінилося), тому їхній bellman_ford_path випереджає базову реалізацію в 2–5 разів на великих масивах даних.
Загальний висновок по алгоритмах на графах
Найкращі результати власні алгоритми показують на малих графах (до 50-100 вершин). У цьому діапазоні різниця з бібліотечними функціями в абсолютних одиницях часу (мілісекундах) є несуттєвою.
Найгірші результати спостерігаються на повних графах (p=1) великої розмірності. Алгоритм Белмана-Форда виявився найменш масштабованим серед обраних через високу обчислювальну складність.
Висновок щодо використання: Для реальних проєктів з великими даними критично використовувати оптимізовані бібліотеки на кшталт NetworkX, проте власна імплементація дозволяє глибше зрозуміти механіку роботи з графами та логіку обходу вузлів.
2. Decision Tree Classifier
Реалізація: Було розроблено модель дерева рішень, яка використовує критерій інформаційного прибутку (Information Gain) або індекс Джіні (Gini Impurity) для розщеплення вузлів.
Аналіз роботи: Модель демонструє високу інтерпретованість — можна чітко простежити, які ознаки (features) є найбільш значущими для прийняття рішення.
Особливості: Власна реалізація добре справляється з лінійно роздільними даними, проте схильна до перенавчання (overfitting) на глибоких деревах без використання прунінгу (обрізки гілок).
Застосування: Даний класифікатор є ефективним інструментом для задач, де важливо розуміти логіку класифікації (наприклад, медична діагностика або скоринг), на відміну від моделей "чорної скриньки".
